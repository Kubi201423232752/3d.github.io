<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>螢幕邊緣對齊繽紛空間</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; cursor: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #video-container {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 80px;
            height: 60px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            z-index: 100;
            opacity: 0.1;
            pointer-events: none;
        }
        #webcam { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #loading {
            position: fixed;
            inset: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            color: #fff;
            font-family: 'Segoe UI', sans-serif;
            z-index: 200;
            letter-spacing: 2px;
            transition: opacity 1s;
        }
    </style>
</head>
<body>

    <div id="loading">正在校準螢幕邊緣空間...</div>

    <div id="video-container">
        <video id="webcam" autoplay playsinline></video>
    </div>

    <script>
        const videoElement = document.getElementById('webcam');
        const loadingScreen = document.getElementById('loading');
        
        let scene, camera, renderer, headLight, room;
        let targets = []; 
        let faceMesh;

        // 空間參數
        const boxDepth = 300; // 稍微增加深度感
        const camZ = 50; // 假設人臉距離螢幕的基礎距離
        const targetCount = 14; 

        // 顏色清單
        const colorPalette = [0xFFFF00, 0x0077FF, 0x00FFFF, 0x9900FF, 0xFF00FF];

        async function init() {
            initThree();
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                videoElement.srcObject = stream;

                faceMesh = new FaceMesh({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
                });

                faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.7
                });

                faceMesh.onResults(onResults);

                videoElement.onloadedmetadata = () => {
                    loadingScreen.style.opacity = '0';
                    setTimeout(() => loadingScreen.remove(), 1000);
                    
                    const predict = async () => {
                        await faceMesh.send({ image: videoElement });
                        requestAnimationFrame(predict);
                    };
                    predict();
                };

                window.addEventListener('resize', onWindowResize);
            } catch (e) {
                loadingScreen.innerText = "無法開啟攝像頭，請檢查權限設定";
            }
        }

        // 建立長方形網格紋理
        function createRectangleGridTexture() {
            const size = 1024;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, size, size);
            
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            const divisions = 8;
            const step = size / divisions;

            for(let i=0; i<=size; i+=step) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, size); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(size, i); ctx.stroke();
            }

            // 白色邊界亮線，用於標示螢幕邊緣
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 12;
            ctx.shadowColor = '#00aaff';
            ctx.shadowBlur = 20;
            ctx.strokeRect(0, 0, size, size);

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            tex.anisotropy = 16;
            return tex;
        }

        function createCubeTarget() {
            const size = 5;
            const geo = new THREE.BoxGeometry(size, size, size);
            const c1 = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            const c2 = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            const mats = [
                new THREE.MeshBasicMaterial({ color: c1 }),
                new THREE.MeshBasicMaterial({ color: c2 }),
                new THREE.MeshBasicMaterial({ color: c1 }),
                new THREE.MeshBasicMaterial({ color: c2 }),
                new THREE.MeshBasicMaterial({ color: c1 }),
                new THREE.MeshBasicMaterial({ color: c2 })
            ];
            return new THREE.Mesh(geo, mats);
        }

        function createSphereTarget() {
            const geo = new THREE.SphereGeometry(3.8, 32, 32);
            const randomColor = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            const mat = new THREE.MeshStandardMaterial({ 
                color: randomColor, 
                emissive: randomColor,
                emissiveIntensity: 0.2,
                roughness: 0.2,
                metalness: 0.8 
            });
            return new THREE.Mesh(geo, mat);
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 150, boxDepth + 50);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, camZ);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            updateRoom();

            for(let i = 0; i < targetCount; i++) {
                const isCube = Math.random() > 0.5;
                const targetObj = isCube ? createCubeTarget() : createSphereTarget();
                
                const baseX = (Math.random() - 0.5) * 60;
                const baseY = (Math.random() - 0.5) * 50;
                const baseZ = -(Math.random() * 200 + 20); 
                targetObj.position.set(baseX, baseY, baseZ);
                scene.add(targetObj);

                const lineColor = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                const lineLen = boxDepth + baseZ;
                const lineGeo = new THREE.CylinderGeometry(0.3, 0.3, lineLen, 8);
                const lineMat = new THREE.MeshBasicMaterial({ 
                    color: lineColor, 
                    transparent: true, 
                    opacity: 0.3 
                });
                const line = new THREE.Mesh(lineGeo, lineMat);
                line.rotation.x = Math.PI / 2;
                line.position.set(baseX, baseY, (baseZ - boxDepth) / 2);
                scene.add(line);

                targets.push({
                    mesh: targetObj,
                    line: line,
                    basePos: new THREE.Vector3(baseX, baseY, baseZ),
                    offsetFactor: 0.02 + Math.random() * 0.05,
                    rotSpeedX: (Math.random() - 0.5) * 0.02,
                    rotSpeedY: (Math.random() - 0.5) * 0.02
                });
            }

            headLight = new THREE.PointLight(0xffffff, 1.5, 600);
            scene.add(headLight);
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));

            animate();
        }

        function updateRoom() {
            if (room) scene.remove(room);
            
            // 關鍵優化：將畫面的寬高定義為場景的前端開口大小
            const aspect = window.innerWidth / window.innerHeight;
            const h = 70; // 垂直基準高度
            const w = h * aspect; // 根據螢幕比例計算寬度

            const gridTex = createRectangleGridTexture();
            const depthRepeat = 15;

            const materials = [
                new THREE.MeshStandardMaterial({ map: gridTex.clone(), side: THREE.BackSide }), // Right
                new THREE.MeshStandardMaterial({ map: gridTex.clone(), side: THREE.BackSide }), // Left
                new THREE.MeshStandardMaterial({ map: gridTex.clone(), side: THREE.BackSide }), // Top
                new THREE.MeshStandardMaterial({ map: gridTex.clone(), side: THREE.BackSide }), // Bottom
                new THREE.MeshStandardMaterial({ color: 0x000000, side: THREE.BackSide }),     // Back
                new THREE.MeshStandardMaterial({ transparent: true, opacity: 0 })               // Front
            ];

            materials[0].map.repeat.set(depthRepeat, 1);
            materials[1].map.repeat.set(depthRepeat, 1);
            materials[2].map.repeat.set(1, depthRepeat);
            materials[3].map.repeat.set(1, depthRepeat);

            // 房間的 BoxGeometry 寬高直接與螢幕比例掛鉤
            const roomGeo = new THREE.BoxGeometry(w, h, boxDepth);
            room = new THREE.Mesh(roomGeo, materials);
            
            // 將房間向後移動，使其「前端」剛好處於相機投影的 Near 平面附近
            room.position.z = -boxDepth / 2; 
            scene.add(room);
            
            // 存儲物理寬高供相機矩陣使用
            room.userData.w = w;
            room.userData.h = h;
        }

        function onResults(results) {
            if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) return;

            const nose = results.multiFaceLandmarks[0][1];
            // 映射人臉座標到空間中的位置
            const targetX = (nose.x - 0.5) * -150; 
            const targetY = (nose.y - 0.5) * -120;

            camera.position.x = THREE.MathUtils.lerp(camera.position.x, targetX, 0.1);
            camera.position.y = THREE.MathUtils.lerp(camera.position.y, targetY, 0.1);
            
            // Off-axis Projection (物理對齊核心邏輯)
            const near = camera.near;
            const focus = camera.position.z; 
            const hw = room.userData.w / 2;
            const hh = room.userData.h / 2;
            
            // 計算相機相對於螢幕中心點的偏移
            const dx = -camera.position.x;
            const dy = -camera.position.y;

            // 重新定義投影矩陣，讓視錐體的開口完美對準螢幕邊緣
            camera.projectionMatrix.makePerspective(
                ( -hw + dx ) * near / focus,
                (  hw + dx ) * near / focus,
                (  hh + dy ) * near / focus,
                ( -hh + dy ) * near / focus,
                near,
                camera.far
            );

            targets.forEach(t => {
                const driftX = camera.position.x * t.offsetFactor;
                const driftY = camera.position.y * t.offsetFactor;
                t.mesh.position.x = t.basePos.x + driftX;
                t.mesh.position.y = t.basePos.y + driftY;
                t.line.position.x = t.mesh.position.x;
                t.line.position.y = t.mesh.position.y;
            });

            headLight.position.copy(camera.position);
        }

        function animate() {
            requestAnimationFrame(animate);
            targets.forEach(t => {
                t.mesh.rotation.x += t.rotSpeedX;
                t.mesh.rotation.y += t.rotSpeedY;
            });
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateRoom();
            // 相機的 Aspect 會在 onResults 的動態矩陣中被覆蓋，所以這裡主要更新渲染器
        }

        window.onload = init;
    </script>
</body>
</html>
