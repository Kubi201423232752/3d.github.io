<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>加粗導引線立體空間</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; cursor: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #video-container {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 80px;
            height: 60px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            z-index: 100;
            opacity: 0.1;
            pointer-events: none;
        }
        #webcam { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #loading {
            position: fixed;
            inset: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            color: #888;
            font-family: 'Segoe UI', sans-serif;
            z-index: 200;
            letter-spacing: 2px;
            transition: opacity 1s;
        }
    </style>
</head>
<body>

    <div id="loading">正在強化光束導引線...</div>

    <div id="video-container">
        <video id="webcam" autoplay playsinline></video>
    </div>

    <script>
        const videoElement = document.getElementById('webcam');
        const loadingScreen = document.getElementById('loading');
        
        let scene, camera, renderer, headLight, room;
        let targets = []; 
        let faceMesh;

        // 空間參數
        const boxDepth = 300; 
        const camZ = 50; 
        const targetCount = 12; 

        async function init() {
            initThree();
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                videoElement.srcObject = stream;

                faceMesh = new FaceMesh({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
                });

                faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.7
                });

                faceMesh.onResults(onResults);

                videoElement.onloadedmetadata = () => {
                    loadingScreen.style.opacity = '0';
                    setTimeout(() => loadingScreen.remove(), 1000);
                    
                    const predict = async () => {
                        await faceMesh.send({ image: videoElement });
                        requestAnimationFrame(predict);
                    };
                    predict();
                };

                window.addEventListener('resize', onWindowResize);
            } catch (e) {
                loadingScreen.innerText = "無法開啟攝像頭，請檢查權限設定";
            }
        }

        // 建立真實網格紋理
        function createRealisticTexture() {
            const size = 1024;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#0f0f0f'; 
            ctx.fillRect(0, 0, size, size);
            
            const imageData = ctx.getImageData(0, 0, size, size);
            const data = imageData.data;
            for(let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 10;
                data[i] = Math.max(0, Math.min(255, data[i] + noise));     
                data[i+1] = Math.max(0, Math.min(255, data[i+1] + noise)); 
                data[i+2] = Math.max(0, Math.min(255, data[i+2] + noise)); 
            }
            ctx.putImageData(imageData, 0, 0);
            
            ctx.strokeStyle = '#3a3a3a'; 
            ctx.lineWidth = 4;
            
            const divisions = 4; 
            const step = size / divisions;

            for(let i=0; i<=size; i+=step) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, size); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(size, i); ctx.stroke();
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            tex.anisotropy = 16;
            return tex;
        }

        // 建立厚實的鏢靶
        function createThickTarget() {
            const innerGroup = new THREE.Group();
            
            const colors = [0xaa0000, 0xffffff, 0xaa0000, 0xffffff, 0xaa0000]; 
            const radii = [5, 3.8, 2.6, 1.4, 0.4]; 

            radii.forEach((r, i) => {
                // 保持 0.6 的實體厚度
                const geo = new THREE.CylinderGeometry(r, r, 0.6, 64);
                
                const mat = new THREE.MeshStandardMaterial({ 
                    color: colors[i],
                    roughness: 0.7,
                    metalness: 0.0,
                });
                const disk = new THREE.Mesh(geo, mat);
                disk.rotation.x = Math.PI / 2;
                
                disk.position.z = i * 0.06; 
                
                disk.castShadow = true;
                disk.receiveShadow = true;
                
                innerGroup.add(disk);
            });

            return innerGroup;
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020202, 0.0035);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1.0, 2000);
            camera.position.set(0, 0, camZ);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            renderer.physicallyCorrectLights = true;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.6;
            
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            document.body.appendChild(renderer.domElement);

            updateRoom();

            const existingPositions = []; 
            const minDistance = 18;       

            for(let i = 0; i < targetCount; i++) {
                const wrapperGroup = new THREE.Group();
                const targetMesh = createThickTarget();
                wrapperGroup.add(targetMesh);
                
                let baseX, baseY, baseZ;
                let validPosition = false;
                let attempts = 0;

                while (!validPosition && attempts < 100) {
                    baseX = (Math.random() - 0.5) * 70;
                    baseY = (Math.random() - 0.5) * 60;
                    baseZ = -(Math.random() * 120 + 5);
                    
                    validPosition = true;
                    for (const pos of existingPositions) {
                        const dx = baseX - pos.x;
                        const dy = baseY - pos.y;
                        const dz = baseZ - pos.z;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        
                        if (dist < minDistance) {
                            validPosition = false;
                            break;
                        }
                    }
                    attempts++;
                }

                existingPositions.push({ x: baseX, y: baseY, z: baseZ });
                
                wrapperGroup.position.set(baseX, baseY, baseZ);
                scene.add(wrapperGroup);

                // 導引線 - 加粗
                const lineColor = 0x00cccc; 
                const lineLen = boxDepth + baseZ;
                // 半徑從 0.2 改為 0.8，增加粗度
                const lineGeo = new THREE.CylinderGeometry(0.8, 0.8, lineLen, 12);
                const lineMat = new THREE.MeshBasicMaterial({ 
                    color: lineColor, 
                    transparent: true, 
                    opacity: 0.3 // 稍微增加一點不透明度，讓粗線更有存在感
                });
                const line = new THREE.Mesh(lineGeo, lineMat);
                line.rotation.x = Math.PI / 2;
                line.position.set(baseX, baseY, (baseZ - boxDepth) / 2);
                scene.add(line);

                targets.push({
                    wrapper: wrapperGroup, 
                    inner: targetMesh,     
                    line: line,
                    basePos: new THREE.Vector3(baseX, baseY, baseZ),
                    offsetFactor: 0.02 + Math.random() * 0.05,
                    rotSpeed: (Math.random() - 0.5) * 0.02
                });
            }

            // 主燈光
            headLight = new THREE.PointLight(0xffffff, 300, 1000); 
            headLight.castShadow = true;
            headLight.shadow.mapSize.width = 2048;
            headLight.shadow.mapSize.height = 2048;
            headLight.shadow.bias = -0.0001;
            headLight.shadow.radius = 4; 
            scene.add(headLight);
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.2));
            
            const rimLight = new THREE.DirectionalLight(0x001144, 0.8);
            rimLight.position.set(0, 0, -100);
            scene.add(rimLight);

            animate();
        }

        function updateRoom() {
            if (room) scene.remove(room);
            
            const aspect = window.innerWidth / window.innerHeight;
            const h = 70; 
            const w = h * aspect;

            const baseGridTex = createRealisticTexture();
            const gridSize = 30; 
            
            const repeatH = h / gridSize;
            const repeatW = w / gridSize;
            const repeatD = boxDepth / gridSize;

            const texRight = baseGridTex.clone();
            const texLeft = baseGridTex.clone();
            const texTop = baseGridTex.clone();
            const texBottom = baseGridTex.clone();
            const texBack = baseGridTex.clone();

            texRight.repeat.set(repeatD, repeatH);
            texLeft.repeat.set(repeatD, repeatH);
            texTop.repeat.set(repeatW, repeatD);
            texBottom.repeat.set(repeatW, repeatD);
            texBack.repeat.set(repeatW, repeatH);

            const commonMatParams = { 
                side: THREE.BackSide,
                roughness: 0.9, 
                metalness: 0.1
            };

            const materials = [
                new THREE.MeshStandardMaterial({ ...commonMatParams, map: texRight }), 
                new THREE.MeshStandardMaterial({ ...commonMatParams, map: texLeft }),  
                new THREE.MeshStandardMaterial({ ...commonMatParams, map: texTop }),   
                new THREE.MeshStandardMaterial({ ...commonMatParams, map: texBottom }),
                new THREE.MeshStandardMaterial({ ...commonMatParams, map: texBack, color: 0x111111 }), 
                new THREE.MeshStandardMaterial({ transparent: true, opacity: 0 })      
            ];

            const roomGeo = new THREE.BoxGeometry(w, h, boxDepth);
            room = new THREE.Mesh(roomGeo, materials);
            room.position.z = -boxDepth / 2; 
            
            room.receiveShadow = true;
            
            scene.add(room);
            
            room.userData.w = w;
            room.userData.h = h;
        }

        function onResults(results) {
            if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) return;

            const nose = results.multiFaceLandmarks[0][1];
            const targetX = (nose.x - 0.5) * -150; 
            const targetY = (nose.y - 0.5) * -120;

            camera.position.x = THREE.MathUtils.lerp(camera.position.x, targetX, 0.25);
            camera.position.y = THREE.MathUtils.lerp(camera.position.y, targetY, 0.25);
            
            const near = camera.near;
            const focus = camera.position.z; 
            const hw = room.userData.w / 2;
            const hh = room.userData.h / 2;
            const dx = -camera.position.x;
            const dy = -camera.position.y;

            camera.projectionMatrix.makePerspective(
                ( -hw + dx ) * near / focus,
                (  hw + dx ) * near / focus,
                (  hh + dy ) * near / focus,
                ( -hh + dy ) * near / focus,
                near,
                camera.far
            );

            targets.forEach(t => {
                const driftX = camera.position.x * t.offsetFactor;
                const driftY = camera.position.y * t.offsetFactor;
                
                t.wrapper.position.x = t.basePos.x + driftX;
                t.wrapper.position.y = t.basePos.y + driftY;
                
                t.line.position.x = t.wrapper.position.x;
                t.line.position.y = t.wrapper.position.y;
            });

            headLight.position.copy(camera.position);
        }

        function animate() {
            requestAnimationFrame(animate);
            targets.forEach(t => {
                t.inner.rotation.z += t.rotSpeed;
            });
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateRoom();
        }

        window.onload = init;
    </script>
</body>
</html>
